\hypertarget{easy_2measurement_8c}{\section{src/fca/easy/measurement.c \-File \-Reference}
\label{easy_2measurement_8c}\index{src/fca/easy/measurement.\-c@{src/fca/easy/measurement.\-c}}
}
{\ttfamily \#include $<$string.\-h$>$}\*
{\ttfamily \#include $<$stdlib.\-h$>$}\*
{\ttfamily \#include $<$math.\-h$>$}\*
{\ttfamily \#include \char`\"{}private.\-h\char`\"{}}\*
\-Include dependency graph for measurement.\-c\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{easy_2measurement_8c__incl}
\end{center}
\end{figure}
\subsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{easy_2measurement_8c_a0d243c594867f254694b0a91409d9b87}{calculate\-Likelihood} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-B, const \hyperlink{common_2measurement_8h_ab2f71cb9d9b10edcc10d44f79ee40d10}{\-Condition\-Map} c, const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-I, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} eta, \hyperlink{common_2measurement_8h_afb8ffb8c068ef8c9fa3677762ac85994}{\-Commutative\-Product} \-L)
\begin{DoxyCompactList}\small\item\em measurement.\-c, (c) 2013, \-Immanuel \-Albrecht; \-Dresden \-University of \-Technology, \-Professur für die \-Psychologie des \-Lernen und \-Lehrens \end{DoxyCompactList}\item 
\hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \hyperlink{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210}{new\-Fake\-Measurement} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-I, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} eta, int experiments, \hyperlink{common_2measurement_8h_ab2f71cb9d9b10edcc10d44f79ee40d10}{\-Condition\-Map} $\ast$output\-\_\-c)
\begin{DoxyCompactList}\small\item\em generates a new formal context that comprises of a pseudo-\/random fake measurement obtained from \-I with the given error probabilites and experiment count \end{DoxyCompactList}\item 
void \hyperlink{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092}{optimize\-Condition\-Map} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-B, \hyperlink{common_2measurement_8h_ab2f71cb9d9b10edcc10d44f79ee40d10}{\-Condition\-Map} c, const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-I, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} restrict eta, const \hyperlink{common_2measurement_8h_ace94e4c4dddc7766492a0f041a72963b}{\-Log\-Cache} log\-\_\-c)
\begin{DoxyCompactList}\small\item\em recalculate the condition map \-C, such that the likelihood of (\-B,c,\-I,eta) is maximal \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{\-Function \-Documentation}
\hypertarget{easy_2measurement_8c_a0d243c594867f254694b0a91409d9b87}{\index{easy/measurement.\-c@{easy/measurement.\-c}!calculate\-Likelihood@{calculate\-Likelihood}}
\index{calculate\-Likelihood@{calculate\-Likelihood}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{calculate\-Likelihood}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf calculate\-Likelihood} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-B, }
\item[{const {\bf \-Condition\-Map}}]{c, }
\item[{const {\bf \-Formal\-Context}}]{\-I, }
\item[{const {\bf \-Eta\-Function}}]{eta, }
\item[{{\bf \-Commutative\-Product}}]{\-L}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a0d243c594867f254694b0a91409d9b87}


measurement.\-c, (c) 2013, \-Immanuel \-Albrecht; \-Dresden \-University of \-Technology, \-Professur für die \-Psychologie des \-Lernen und \-Lehrens 

\hyperlink{easy_2measurement_8h}{easy/measurement.\-h}, (c) 2013, \-Immanuel \-Albrecht; \-Dresden \-University of \-Technology, \-Professur für die \-Psychologie des \-Lernen und \-Lehrens

\-This program is free software\-: you can redistribute it and/or modify it under the terms of the \-G\-N\-U \-General \-Public \-License as published by the \-Free \-Software \-Foundation, either version 3 of the \-License, or (at your option) any later version.

\-This program is distributed in the hope that it will be useful, but \-W\-I\-T\-H\-O\-U\-T \-A\-N\-Y \-W\-A\-R\-R\-A\-N\-T\-Y; without even the implied warranty of \-M\-E\-R\-C\-H\-A\-N\-T\-A\-B\-I\-L\-I\-T\-Y or \-F\-I\-T\-N\-E\-S\-S \-F\-O\-R \-A \-P\-A\-R\-T\-I\-C\-U\-L\-A\-R \-P\-U\-R\-P\-O\-S\-E. \-See the \-G\-N\-U \-General \-Public \-License for more details.

\-You should have received a copy of the \-G\-N\-U \-General \-Public \-License along with this program. \-If not, see $<$\href{http://www.gnu.org/licenses/}{\tt http\-://www.\-gnu.\-org/licenses/}$>$. calculates the likelihood function \-L 
\begin{DoxyParams}{\-Parameters}
{\em \-B} & the measurement context \\
\hline
{\em c} & the condition map (mapping objects \\
\hline
{\em \-I} & \\
\hline
{\em eta} & \\
\hline
{\em \-L} & \\
\hline
\end{DoxyParams}


\-Definition at line 34 of file measurement.\-c.



\-References s\-Condition\-Map\-::c, s\-Eta\-Function\-::constants, s\-Commutative\-Product\-::constants, s\-Eta\-Function\-::eta, g\-Im, s\-Commutative\-Product\-::match, s\-Eta\-Function\-::measurements, s\-Commutative\-Product\-::mismatch, s\-Condition\-Map\-::objects, \-R\-E\-T\-U\-R\-N\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, s\-Eta\-Function\-::types, \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-G\-E\-Q\-\_\-\-D\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.


\begin{DoxyCode}
{
    RETURN_IF_ZERO(B);
    RETURN_IF_ZERO(c);
    RETURN_IF_ZERO(I);
    RETURN_IF_ZERO(eta);
    RETURN_IF_ZERO(L);

    const myFormalContext* restrict b;
    b = (const myFormalContext*) B;

    const myFormalContext* restrict i;
    i = (const myFormalContext*) I;

    WARN_IF_UNEQUAL_DO(b->objects, (int )c->objects, return);
    WARN_IF_UNEQUAL_DO(b->attributes, i->attributes, return);
    WARN_IF_UNEQUAL_DO(i->attributes, (int ) eta->measurements, return);
    WARN_IF_UNEQUAL_DO(2, eta->types, return);
    WARN_IF_UNEQUAL_DO(eta->constants, L->constants,);

    memset(L->match, 0, sizeof(size_t) * L->constants);
    memset(L->mismatch, 0, sizeof(size_t) * L->constants);

    for (int g = 0; g < b->objects; ++g)
    {
        int c_g;
        c_g = (int) c->c[g];

        WARN_IF_GEQ_DO(c_g, i->objects, continue);

        for (int m = 0; m < b->attributes; ++m)
        {
            if (gIm(c_g,i,m))
            {
                if (gIm(g,b,m))
                {
                    L->match[eta->eta[b->attributes + m]]++;
                }
                else
                {
                    L->mismatch[eta->eta[b->attributes + m]]++;
                }
            }
            else
            {
                if (gIm(g,b,m))
                {
                    L->mismatch[eta->eta[m]]++;
                }
                else
                {
                    L->match[eta->eta[m]]++;
                }
            }
        }
    }
}
\end{DoxyCode}
\hypertarget{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210}{\index{easy/measurement.\-c@{easy/measurement.\-c}!new\-Fake\-Measurement@{new\-Fake\-Measurement}}
\index{new\-Fake\-Measurement@{new\-Fake\-Measurement}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{new\-Fake\-Measurement}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Formal\-Context} {\bf new\-Fake\-Measurement} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-I, }
\item[{const {\bf \-Eta\-Function}}]{eta, }
\item[{int}]{experiments, }
\item[{{\bf \-Condition\-Map} $\ast$}]{output\-\_\-c}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210}


generates a new formal context that comprises of a pseudo-\/random fake measurement obtained from \-I with the given error probabilites and experiment count 


\begin{DoxyParams}{\-Parameters}
{\em \-I} & experimental condition context \\
\hline
{\em eta} & error probabilities \\
\hline
{\em experiments} & number of conducted experiments \\
\hline
{\em output\-\_\-c} & a new \-Condition\-Map will be generated to this pointer, if nonzero \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
a new \-Formal\-Context object 
\end{DoxyReturn}


\-Definition at line 103 of file measurement.\-c.



\-References s\-Eta\-Function\-::\-C, \-C\-E\-L\-L, \-C\-R\-O\-S\-S, s\-Eta\-Function\-::eta, g\-Im, s\-Eta\-Function\-::measurements, \-M\-I\-N, new\-Condition\-Map(), new\-Formal\-Context, \-R\-E\-T\-U\-R\-N\-\_\-\-Z\-E\-R\-O\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.



\-Referenced by main().


\begin{DoxyCode}
{
    RETURN_ZERO_IF_ZERO(I);
    RETURN_ZERO_IF_ZERO(eta);

    const myFormalContext* restrict i;
    i = (const myFormalContext*) I;

    WARN_IF_UNEQUAL_DO(i->attributes, (int ) eta->measurements, return 0);

    if (output_c)
        *output_c = newConditionMap(experiments);

    myFormalContext *b;
    b = (myFormalContext *) newFormalContext(experiments, i->attributes);

    for (int x = 0; x < experiments; ++x)
    {
        int c_x;
        c_x =
                MIN((int) floor((double) (random()) /
                                (double) RAND_MAX * (double)i->objects), i->
      objects-1);

        if (output_c)
            (*output_c)->c[x] = c_x;

        for (int m = 0; m < i->attributes; ++m)
        {
            Probability rnd;
            rnd = (Probability) random() / (Probability) RAND_MAX;

            if (gIm(c_x,i,m))
            {
                if (rnd >= eta->C[eta->eta[i->attributes + m]])
                    CROSS(CELL(x,b,m));
            }
            else
            {
                if (rnd < eta->C[eta->eta[m]])
                    CROSS(CELL(x,b,m));
            }
        }
    }

    return (FormalContext) b;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210_cgraph}
\end{center}
\end{figure}


\hypertarget{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092}{\index{easy/measurement.\-c@{easy/measurement.\-c}!optimize\-Condition\-Map@{optimize\-Condition\-Map}}
\index{optimize\-Condition\-Map@{optimize\-Condition\-Map}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{optimize\-Condition\-Map}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf optimize\-Condition\-Map} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-B, }
\item[{{\bf \-Condition\-Map}}]{c, }
\item[{const {\bf \-Formal\-Context}}]{\-I, }
\item[{const {\bf \-Eta\-Function} restrict}]{eta, }
\item[{const {\bf \-Log\-Cache}}]{log\-\_\-c}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092}


recalculate the condition map \-C, such that the likelihood of (\-B,c,\-I,eta) is maximal 


\begin{DoxyParams}{\-Parameters}
{\em \-B} & the measurement context \\
\hline
{\em c} & output\-: \-Condition\-Map that will be filled with c\-\_\-\{\-I,eta\} \\
\hline
{\em \-I} & the condition context \\
\hline
{\em eta} & the error probabilities \\
\hline
{\em log\-\_\-c} & log constants corresponding to eta \\
\hline
\end{DoxyParams}


\-Definition at line 161 of file measurement.\-c.



\-References s\-Condition\-Map\-::c, s\-Log\-Cache\-::constants, delete\-Commutative\-Product(), g\-Im, \-L\-O\-G\-\_\-\-P\-R\-O\-B\-\_\-\-L\-O\-W\-E\-R\-\_\-\-B\-O\-U\-N\-D, log\-Probability\-From\-Product(), new\-Commutative\-Product(), s\-Condition\-Map\-::objects, \-R\-E\-T\-U\-R\-N\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.



\-Referenced by main().


\begin{DoxyCode}
{
    RETURN_IF_ZERO(B);
    RETURN_IF_ZERO(c);
    RETURN_IF_ZERO(I);
    RETURN_IF_ZERO(eta);
    RETURN_IF_ZERO(log_c);

    const myFormalContext* restrict b;
    b = (const myFormalContext*) B;

    const myFormalContext* restrict i;
    i = (const myFormalContext*) I;

    WARN_IF_UNEQUAL_DO(b->objects, (int )c->objects, return);
    WARN_IF_UNEQUAL_DO(b->attributes, i->attributes, return);
    WARN_IF_UNEQUAL_DO(b->attributes, (int )eta->measurements, return);
    WARN_IF_UNEQUAL_DO(2, eta->types, return);
    WARN_IF_UNEQUAL_DO(eta->constants, log_c->constants, return);

    size_t attributes;
    attributes = (size_t) b->attributes;

    CommutativeProduct lp;
    lp = newCommutativeProduct(eta->constants);

    CommutativeProduct restrict l;
    l = lp;

    /*
     * For every object index x of B, find the last object index of I, such
       that
     * the likelihood that experiment x was conducted under that condition is
       maximal.
     */

    for (size_t x = 0; x < (size_t) b->objects; ++x)
    {

        size_t best_cx;
        best_cx = 0;

        /*
         * initialize the current maximal probability with the bottom value of
         * LogProbability
         */

        LogProbability maximal_prob;
        maximal_prob = LOG_PROB_LOWER_BOUND;

        for (size_t cx = 0; cx < (size_t) i->objects; ++cx)
        {
            /*
             * calculate (partial) likelihood if c(x) = cx
             */
            memset(l->match, 0, sizeof(size_t) * l->constants);
            memset(l->mismatch, 0, sizeof(size_t) * l->constants);

            for (size_t m = 0; m < attributes; ++m)
            {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
                if (gIm(x,b,m))
                {
                    if (gIm(cx,i,m))
                    {
#pragma GCC diagnostic pop
                        /*
                         * 1-eta(m,1)
                         */
                        l->match[eta->eta[1 * eta->constants + m]]++;
                        //printf("X");
                    }
                    else
                    {
                        /*
                         * eta(m,0)
                         */
                        l->mismatch[eta->eta[0 * eta->constants + m]]++;
                        //printf("O");
                    }
                }
                else
                {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
                    if (gIm(cx,i,m))
                    {
#pragma GCC diagnostic pop
                        /*
                         * eta(m,0)
                         */
                        l->mismatch[eta->eta[1 * eta->constants + m]]++;
                        //printf("_");
                    }
                    else
                    {
                        /*
                         * 1-eta(m,0)
                         */
                        l->match[eta->eta[0 * eta->constants + m]]++;
                        //printf(".");
                    }
                }
            }

            LogProbability p;
            p = logProbabilityFromProduct(log_c, l);

            //printf("%f\t", p);

            /*
             * cx is more likely than best_cx
             * so, update cx -> best_cx
             */

            if (maximal_prob <= p)
            {
                maximal_prob = p;
                best_cx = cx;
            }
        }

        /*
         * choose the most likely match
         */

        c->c[x] = best_cx;
        //printf("c(%4zu) = %4zu\n", x, c->c[x]);
    }

    deleteCommutativeProduct(&lp);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092_cgraph}
\end{center}
\end{figure}


