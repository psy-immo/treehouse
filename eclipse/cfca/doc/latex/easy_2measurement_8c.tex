\hypertarget{easy_2measurement_8c}{\section{src/fca/easy/measurement.c \-File \-Reference}
\label{easy_2measurement_8c}\index{src/fca/easy/measurement.\-c@{src/fca/easy/measurement.\-c}}
}
{\ttfamily \#include $<$string.\-h$>$}\*
{\ttfamily \#include $<$stdlib.\-h$>$}\*
{\ttfamily \#include $<$math.\-h$>$}\*
{\ttfamily \#include \char`\"{}private.\-h\char`\"{}}\*
\-Include dependency graph for measurement.\-c\-:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{easy_2measurement_8c__incl}
\end{center}
\end{figure}
\subsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{easy_2measurement_8c_a0d243c594867f254694b0a91409d9b87}{calculate\-Likelihood} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-B, const \hyperlink{common_2measurement_8h_ab2f71cb9d9b10edcc10d44f79ee40d10}{\-Condition\-Map} c, const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-I, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} eta, \hyperlink{common_2measurement_8h_afb8ffb8c068ef8c9fa3677762ac85994}{\-Commutative\-Product} \-L)
\begin{DoxyCompactList}\small\item\em measurement.\-c, (c) 2013, \-Immanuel \-Albrecht; \-Dresden \-University of \-Technology, \-Professur für die \-Psychologie des \-Lernen und \-Lehrens \end{DoxyCompactList}\item 
\hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \hyperlink{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210}{new\-Fake\-Measurement} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-I, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} eta, int experiments, \hyperlink{common_2measurement_8h_ab2f71cb9d9b10edcc10d44f79ee40d10}{\-Condition\-Map} $\ast$output\-\_\-c)
\begin{DoxyCompactList}\small\item\em generates a new formal context that comprises of a pseudo-\/random fake measurement obtained from \-I with the given error probabilites and experiment count \end{DoxyCompactList}\item 
void \hyperlink{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092}{optimize\-Condition\-Map} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-B, \hyperlink{common_2measurement_8h_ab2f71cb9d9b10edcc10d44f79ee40d10}{\-Condition\-Map} c, const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-I, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} restrict eta, const \hyperlink{common_2measurement_8h_ace94e4c4dddc7766492a0f041a72963b}{\-Log\-Cache} log\-\_\-c)
\begin{DoxyCompactList}\small\item\em recalculate the condition map \-C, such that the likelihood of (\-B,c,\-I,eta) is maximal \end{DoxyCompactList}\item 
void \hyperlink{easy_2measurement_8c_a1de1f8bcc4d06953f1b5bb130389aa3f}{optimize\-Approximation\-Context} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-B, const \hyperlink{common_2measurement_8h_ab2f71cb9d9b10edcc10d44f79ee40d10}{\-Condition\-Map} cmap, \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-I, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} restrict eta, const \hyperlink{common_2measurement_8h_ace94e4c4dddc7766492a0f041a72963b}{\-Log\-Cache} log\-\_\-c)
\begin{DoxyCompactList}\small\item\em optimize the approximated context for a given measurement and condition map \end{DoxyCompactList}\item 
\hyperlink{common_2measurement_8h_a315318def4482768da7077f76ff0c768}{\-Distance\-Matrix} \hyperlink{easy_2measurement_8c_a63b673e042e8f51a7587322bf49ab7f2}{new\-Distance\-Matrix\-From\-Context} (const \hyperlink{easy_8h_ad53dc3fc96151a44387245e6481f95a4}{\-Formal\-Context} \-B, const \hyperlink{common_2measurement_8h_ab2406aaef0ce3e9f38a79f42ce470ffb}{\-Eta\-Function} restrict eta, const \hyperlink{common_2measurement_8h_ace94e4c4dddc7766492a0f041a72963b}{\-Log\-Cache} log\-\_\-c)
\begin{DoxyCompactList}\small\item\em calculates the asymmetric distances for some measurement context \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{\-Function \-Documentation}
\hypertarget{easy_2measurement_8c_a0d243c594867f254694b0a91409d9b87}{\index{easy/measurement.\-c@{easy/measurement.\-c}!calculate\-Likelihood@{calculate\-Likelihood}}
\index{calculate\-Likelihood@{calculate\-Likelihood}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{calculate\-Likelihood}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf calculate\-Likelihood} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-B, }
\item[{const {\bf \-Condition\-Map}}]{c, }
\item[{const {\bf \-Formal\-Context}}]{\-I, }
\item[{const {\bf \-Eta\-Function}}]{eta, }
\item[{{\bf \-Commutative\-Product}}]{\-L}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a0d243c594867f254694b0a91409d9b87}


measurement.\-c, (c) 2013, \-Immanuel \-Albrecht; \-Dresden \-University of \-Technology, \-Professur für die \-Psychologie des \-Lernen und \-Lehrens 

\hyperlink{easy_2measurement_8h}{easy/measurement.\-h}, (c) 2013, \-Immanuel \-Albrecht; \-Dresden \-University of \-Technology, \-Professur für die \-Psychologie des \-Lernen und \-Lehrens

\-This program is free software\-: you can redistribute it and/or modify it under the terms of the \-G\-N\-U \-General \-Public \-License as published by the \-Free \-Software \-Foundation, either version 3 of the \-License, or (at your option) any later version.

\-This program is distributed in the hope that it will be useful, but \-W\-I\-T\-H\-O\-U\-T \-A\-N\-Y \-W\-A\-R\-R\-A\-N\-T\-Y; without even the implied warranty of \-M\-E\-R\-C\-H\-A\-N\-T\-A\-B\-I\-L\-I\-T\-Y or \-F\-I\-T\-N\-E\-S\-S \-F\-O\-R \-A \-P\-A\-R\-T\-I\-C\-U\-L\-A\-R \-P\-U\-R\-P\-O\-S\-E. \-See the \-G\-N\-U \-General \-Public \-License for more details.

\-You should have received a copy of the \-G\-N\-U \-General \-Public \-License along with this program. \-If not, see $<$\href{http://www.gnu.org/licenses/}{\tt http\-://www.\-gnu.\-org/licenses/}$>$. calculates the likelihood function \-L 
\begin{DoxyParams}{\-Parameters}
{\em \-B} & the measurement context \\
\hline
{\em c} & the condition map (mapping objects \\
\hline
{\em \-I} & \\
\hline
{\em eta} & \\
\hline
{\em \-L} & \\
\hline
\end{DoxyParams}


\-Definition at line 34 of file measurement.\-c.



\-References s\-Condition\-Map\-::c, s\-Eta\-Function\-::constants, s\-Commutative\-Product\-::constants, s\-Eta\-Function\-::eta, g\-Im, s\-Commutative\-Product\-::match, s\-Eta\-Function\-::measurements, s\-Commutative\-Product\-::mismatch, s\-Condition\-Map\-::objects, \-R\-E\-T\-U\-R\-N\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, s\-Eta\-Function\-::types, \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-G\-E\-Q\-\_\-\-D\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.


\begin{DoxyCode}
{
    RETURN_IF_ZERO(B);
    RETURN_IF_ZERO(c);
    RETURN_IF_ZERO(I);
    RETURN_IF_ZERO(eta);
    RETURN_IF_ZERO(L);

    const myFormalContext* restrict b;
    b = (const myFormalContext*) B;

    const myFormalContext* restrict i;
    i = (const myFormalContext*) I;

    WARN_IF_UNEQUAL_DO(b->objects, (int )c->objects, return);
    WARN_IF_UNEQUAL_DO(b->attributes, i->attributes, return);
    WARN_IF_UNEQUAL_DO(i->attributes, (int ) eta->measurements, return);
    WARN_IF_UNEQUAL_DO(2, eta->types, return);
    WARN_IF_UNEQUAL_DO(eta->constants, L->constants,);

    memset(L->match, 0, sizeof(size_t) * L->constants);
    memset(L->mismatch, 0, sizeof(size_t) * L->constants);

    for (int g = 0; g < b->objects; ++g)
    {
        int c_g;
        c_g = (int) c->c[g];

        WARN_IF_GEQ_DO(c_g, i->objects, continue);

        for (int m = 0; m < b->attributes; ++m)
        {
            if (gIm(c_g,i,m))
            {
                if (gIm(g,b,m))
                {
                    L->match[eta->eta[b->attributes + m]]++;
                }
                else
                {
                    L->mismatch[eta->eta[b->attributes + m]]++;
                }
            }
            else
            {
                if (gIm(g,b,m))
                {
                    L->mismatch[eta->eta[m]]++;
                }
                else
                {
                    L->match[eta->eta[m]]++;
                }
            }
        }
    }
}
\end{DoxyCode}
\hypertarget{easy_2measurement_8c_a63b673e042e8f51a7587322bf49ab7f2}{\index{easy/measurement.\-c@{easy/measurement.\-c}!new\-Distance\-Matrix\-From\-Context@{new\-Distance\-Matrix\-From\-Context}}
\index{new\-Distance\-Matrix\-From\-Context@{new\-Distance\-Matrix\-From\-Context}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{new\-Distance\-Matrix\-From\-Context}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Distance\-Matrix} {\bf new\-Distance\-Matrix\-From\-Context} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-B, }
\item[{const {\bf \-Eta\-Function} restrict}]{eta, }
\item[{const {\bf \-Log\-Cache}}]{log\-\_\-c}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a63b673e042e8f51a7587322bf49ab7f2}


calculates the asymmetric distances for some measurement context 


\begin{DoxyParams}{\-Parameters}
{\em \-B} & the measurement context \\
\hline
{\em eta} & the error probabilities \\
\hline
{\em log\-\_\-c} & the logarithms corresponding to eta \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
a new \-Distance\-Matrix 
\end{DoxyReturn}


\-Definition at line 469 of file measurement.\-c.



\-References s\-Log\-Cache\-::constants, delete\-Commutative\-Product(), g\-Im, log\-Probability\-From\-Product(), s\-Commutative\-Product\-::match, s\-Commutative\-Product\-::mismatch, new\-Commutative\-Product(), new\-Distance\-Matrix(), \-R\-E\-T\-U\-R\-N\-\_\-\-Z\-E\-R\-O\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.



\-Referenced by main().


\begin{DoxyCode}
{
    RETURN_ZERO_IF_ZERO(B);
    RETURN_ZERO_IF_ZERO(eta);
    RETURN_ZERO_IF_ZERO(log_c);

    const myFormalContext* restrict b;
    b = (const myFormalContext*) B;

    WARN_IF_UNEQUAL_DO(b->attributes, (int )eta->measurements, return 0);
    WARN_IF_UNEQUAL_DO(2, eta->types, return 0);
    WARN_IF_UNEQUAL_DO(eta->constants, log_c->constants, return 0);

    size_t attributes;
    attributes = (size_t) b->attributes;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"

    size_t measurements;
    measurements = b->objects;

#pragma GCC diagnostic pop

    DistanceMatrix d;
    d = newDistanceMatrix(measurements);

    CommutativeProduct dxy, dyx;

    dxy = newCommutativeProduct(eta->constants);
    dyx = newCommutativeProduct(eta->constants);

    /*
     * calculate the distances d(x,y) and d(y,x) in parallel
     */

    for (size_t x = 0; x < measurements; ++x)
    {
        for (size_t y = x; y < measurements; ++y)
        {
            /*
             * set dxy and dyx to zero
             */
            for (size_t i = 0; i < eta->constants; ++i)
            {
                dxy->match[i] = 0;
                dxy->mismatch[i] = 0;

                dyx->match[i] = 0;
                dyx->mismatch[i] = 0;
            }

            /*
             * check where the attribute vectors coincide and where not
             */

            for (size_t m = 0; m < attributes; ++m)
            {
                size_t eta_m0, eta_m1;

                eta_m0 = eta->eta[0 * eta->constants + m];
                eta_m1 = eta->eta[1 * eta->constants + m];

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"

                if (gIm(x,b,m))
                {
                    if (gIm(y,b,m))
                    {

                        dxy->match[eta_m1]++;
                        dyx->match[eta_m1]++;
                    }
                    else
                    {
                        dxy->mismatch[eta_m1]++;
                        dyx->mismatch[eta_m0]++;
                    }
                }
                else
                {
                    if (gIm(y,b,m))
                    {
                        dxy->mismatch[eta_m0]++;
                        dyx->mismatch[eta_m1]++;
                    }
                    else
                    {
                        dxy->match[eta_m0]++;
                        dyx->match[eta_m0]++;
                    }
                }

#pragma GCC diagnostic pop
            }

            /*
             * calculate the logarithms of the likelihoods
             */

            d->d[x * measurements + y] = logProbabilityFromProduct(log_c, dxy);
            d->d[y * measurements + x] = logProbabilityFromProduct(log_c, dyx);
        }
    }

    deleteCommutativeProduct(&dxy);
    deleteCommutativeProduct(&dyx);

    return d;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{easy_2measurement_8c_a63b673e042e8f51a7587322bf49ab7f2_cgraph}
\end{center}
\end{figure}


\hypertarget{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210}{\index{easy/measurement.\-c@{easy/measurement.\-c}!new\-Fake\-Measurement@{new\-Fake\-Measurement}}
\index{new\-Fake\-Measurement@{new\-Fake\-Measurement}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{new\-Fake\-Measurement}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Formal\-Context} {\bf new\-Fake\-Measurement} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-I, }
\item[{const {\bf \-Eta\-Function}}]{eta, }
\item[{int}]{experiments, }
\item[{{\bf \-Condition\-Map} $\ast$}]{output\-\_\-c}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210}


generates a new formal context that comprises of a pseudo-\/random fake measurement obtained from \-I with the given error probabilites and experiment count 


\begin{DoxyParams}{\-Parameters}
{\em \-I} & experimental condition context \\
\hline
{\em eta} & error probabilities \\
\hline
{\em experiments} & number of conducted experiments \\
\hline
{\em output\-\_\-c} & a new \-Condition\-Map will be generated to this pointer, if nonzero \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
a new \-Formal\-Context object 
\end{DoxyReturn}


\-Definition at line 103 of file measurement.\-c.



\-References s\-Eta\-Function\-::\-C, \-C\-E\-L\-L, \-C\-R\-O\-S\-S, s\-Eta\-Function\-::eta, g\-Im, s\-Eta\-Function\-::measurements, \-M\-I\-N, new\-Condition\-Map(), new\-Formal\-Context, \-R\-E\-T\-U\-R\-N\-\_\-\-Z\-E\-R\-O\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.



\-Referenced by main().


\begin{DoxyCode}
{
    RETURN_ZERO_IF_ZERO(I);
    RETURN_ZERO_IF_ZERO(eta);

    const myFormalContext* restrict i;
    i = (const myFormalContext*) I;

    WARN_IF_UNEQUAL_DO(i->attributes, (int ) eta->measurements, return 0);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"

    if (output_c)
        *output_c = newConditionMap(experiments);

#pragma GCC diagnostic pop

    myFormalContext *b;
    b = (myFormalContext *) newFormalContext(experiments, i->attributes);

    for (int x = 0; x < experiments; ++x)
    {
        int c_x;
        c_x =
                MIN((int) floor((double) (random()) /
                                (double) RAND_MAX * (double)i->objects), i->
      objects-1);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"

        if (output_c)
            (*output_c)->c[x] = c_x;

#pragma GCC diagnostic pop

        for (int m = 0; m < i->attributes; ++m)
        {
            Probability rnd;
            rnd = (Probability) random() / (Probability) RAND_MAX;

            if (gIm(c_x,i,m))
            {
                if (rnd >= eta->C[eta->eta[i->attributes + m]])
                    CROSS(CELL(x,b,m));
            }
            else
            {
                if (rnd < eta->C[eta->eta[m]])
                    CROSS(CELL(x,b,m));
            }
        }
    }

    return (FormalContext) b;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{easy_2measurement_8c_a9f03ccc14548b541ae120c6b869c1210_cgraph}
\end{center}
\end{figure}


\hypertarget{easy_2measurement_8c_a1de1f8bcc4d06953f1b5bb130389aa3f}{\index{easy/measurement.\-c@{easy/measurement.\-c}!optimize\-Approximation\-Context@{optimize\-Approximation\-Context}}
\index{optimize\-Approximation\-Context@{optimize\-Approximation\-Context}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{optimize\-Approximation\-Context}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf optimize\-Approximation\-Context} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-B, }
\item[{const {\bf \-Condition\-Map}}]{cmap, }
\item[{{\bf \-Formal\-Context}}]{\-I, }
\item[{const {\bf \-Eta\-Function} restrict}]{eta, }
\item[{const {\bf \-Log\-Cache}}]{log\-\_\-c}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a1de1f8bcc4d06953f1b5bb130389aa3f}


optimize the approximated context for a given measurement and condition map 


\begin{DoxyParams}{\-Parameters}
{\em \-B} & the measurement context \\
\hline
{\em cmap} & condition map \\
\hline
{\em \-I} & output\-: new approximated context \\
\hline
{\em eta} & the error probabilities \\
\hline
{\em log\-\_\-c} & log constants corresponding to eta \\
\hline
\end{DoxyParams}


\-Definition at line 314 of file measurement.\-c.



\-References smy\-Formal\-Context\-::attributes, s\-Condition\-Map\-::c, \-C\-E\-L\-L, \-C\-L\-E\-A\-R, s\-Log\-Cache\-::constants, \-C\-R\-O\-S\-S, delete\-Commutative\-Product(), g\-Im, log\-Probability\-From\-Product(), new\-Commutative\-Product(), smy\-Formal\-Context\-::objects, s\-Condition\-Map\-::objects, \-R\-E\-T\-U\-R\-N\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.



\-Referenced by main().


\begin{DoxyCode}
{
    RETURN_IF_ZERO(B);
    RETURN_IF_ZERO(cmap);
    RETURN_IF_ZERO(I);
    RETURN_IF_ZERO(eta);
    RETURN_IF_ZERO(log_c);

    const myFormalContext* restrict b;
    b = (const myFormalContext*) B;

    myFormalContext* i;
    i = (myFormalContext*) I;

    WARN_IF_UNEQUAL_DO(b->objects, (int )cmap->objects, return);
    WARN_IF_UNEQUAL_DO(b->attributes, i->attributes, return);
    WARN_IF_UNEQUAL_DO(b->attributes, (int )eta->measurements, return);
    WARN_IF_UNEQUAL_DO(2, eta->types, return);
    WARN_IF_UNEQUAL_DO(eta->constants, log_c->constants, return);

    size_t attributes;
    attributes = (size_t) b->attributes;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"

    size_t measurements;
    measurements = b->objects;

    size_t conditions;
    conditions = i->objects;

#pragma GCC diagnostic pop

    CommutativeProduct *l_array;

    l_array = malloc(sizeof(CommutativeProduct) * conditions * 2);

    CommutativeProduct restrict * l_cross;
    l_cross = (CommutativeProduct restrict *) l_array;

    CommutativeProduct restrict * l_gap;
    l_gap = (CommutativeProduct restrict *) (l_array + conditions);

    for (size_t c = 0; c < conditions; ++c)
    {
        l_cross[c] = newCommutativeProduct(eta->constants);
        l_gap[c] = newCommutativeProduct(eta->constants);
    }

    /*
     * check column wise, whether there should be a cross in the incidence
       matrix I
     * or not.
     */

    for (size_t a = 0; a < attributes; ++a)
    {
        size_t eta_a0, eta_a1;

        eta_a0 = eta->eta[0 * eta->constants + a];
        eta_a1 = eta->eta[1 * eta->constants + a];

        for (size_t c = 0; c < conditions; ++c)
        {
            for (size_t i = 0; i < eta->constants; ++i)
            {
                l_cross[c]->match[i] = 0;
                l_cross[c]->mismatch[i] = 0;
                l_gap[c]->match[i] = 0;
                l_gap[c]->mismatch[i] = 0;
            }
        }

        /*
         * count how often we measured attribute a for each condition cmap
         * and fill it in the corresponding CommutativeProduct
         */

        for (size_t o = 0; o < measurements; ++o)
        {
            size_t condition;
            condition = cmap->c[o];

            /*
             * add up in parallel both error vectors for both cross and gap
       case
             * in the approximation
             */

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"

            if (gIm(o, b, a))
            {
                l_cross[condition]->match[eta_a1]++;
                l_gap[condition]->mismatch[eta_a0]++;
            }
            else
            {
                l_cross[condition]->mismatch[eta_a1]++;
                l_gap[condition]->match[eta_a0]++;
            }

#pragma GCC diagnostic pop
        }

        /*
         * now each l_cross[c] and l_gap[c] contain the same indexed factors
       for
         * the likelihoods with and without a cross for c I a
         * we sum up both and the bigger wins
         */

        for (size_t c = 0; c < conditions; ++c)
        {
            LogProbability cross;
            LogProbability gap;

            cross = logProbabilityFromProduct(log_c, l_cross[c]);
            gap = logProbabilityFromProduct(log_c, l_gap[c]);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"

            if (gap <= cross)
            {
                CROSS(CELL(c,i,a));
            }
            else
            {
                CLEAR(CELL(c,i,a));
            }

#pragma GCC diagnostic pop
        }
    }

    for (size_t c = 0; c < conditions; ++c)
    {
        deleteCommutativeProduct(l_array + c);
        deleteCommutativeProduct(l_array + c + conditions);
    }

    free(l_array);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{easy_2measurement_8c_a1de1f8bcc4d06953f1b5bb130389aa3f_cgraph}
\end{center}
\end{figure}


\hypertarget{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092}{\index{easy/measurement.\-c@{easy/measurement.\-c}!optimize\-Condition\-Map@{optimize\-Condition\-Map}}
\index{optimize\-Condition\-Map@{optimize\-Condition\-Map}!easy/measurement.c@{easy/measurement.\-c}}
\subsubsection[{optimize\-Condition\-Map}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf optimize\-Condition\-Map} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Formal\-Context}}]{\-B, }
\item[{{\bf \-Condition\-Map}}]{c, }
\item[{const {\bf \-Formal\-Context}}]{\-I, }
\item[{const {\bf \-Eta\-Function} restrict}]{eta, }
\item[{const {\bf \-Log\-Cache}}]{log\-\_\-c}
\end{DoxyParamCaption}
)}}\label{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092}


recalculate the condition map \-C, such that the likelihood of (\-B,c,\-I,eta) is maximal 


\begin{DoxyParams}{\-Parameters}
{\em \-B} & the measurement context \\
\hline
{\em c} & output\-: \-Condition\-Map that will be filled with c\-\_\-\{\-I,eta\} \\
\hline
{\em \-I} & the condition context \\
\hline
{\em eta} & the error probabilities \\
\hline
{\em log\-\_\-c} & log constants corresponding to eta \\
\hline
\end{DoxyParams}


\-Definition at line 171 of file measurement.\-c.



\-References s\-Condition\-Map\-::c, s\-Log\-Cache\-::constants, delete\-Commutative\-Product(), g\-Im, \-L\-O\-G\-\_\-\-P\-R\-O\-B\-\_\-\-L\-O\-W\-E\-R\-\_\-\-B\-O\-U\-N\-D, log\-Probability\-From\-Product(), new\-Commutative\-Product(), s\-Condition\-Map\-::objects, \-R\-E\-T\-U\-R\-N\-\_\-\-I\-F\-\_\-\-Z\-E\-R\-O, and \-W\-A\-R\-N\-\_\-\-I\-F\-\_\-\-U\-N\-E\-Q\-U\-A\-L\-\_\-\-D\-O.



\-Referenced by main().


\begin{DoxyCode}
{
    RETURN_IF_ZERO(B);
    RETURN_IF_ZERO(c);
    RETURN_IF_ZERO(I);
    RETURN_IF_ZERO(eta);
    RETURN_IF_ZERO(log_c);

    const myFormalContext* restrict b;
    b = (const myFormalContext*) B;

    const myFormalContext* restrict i;
    i = (const myFormalContext*) I;

    WARN_IF_UNEQUAL_DO(b->objects, (int )c->objects, return);
    WARN_IF_UNEQUAL_DO(b->attributes, i->attributes, return);
    WARN_IF_UNEQUAL_DO(b->attributes, (int )eta->measurements, return);
    WARN_IF_UNEQUAL_DO(2, eta->types, return);
    WARN_IF_UNEQUAL_DO(eta->constants, log_c->constants, return);

    size_t attributes;
    attributes = (size_t) b->attributes;

    CommutativeProduct lp;
    lp = newCommutativeProduct(eta->constants);

    CommutativeProduct restrict l;
    l = lp;

    /*
     * For every object index x of B, find the last object index of I, such
       that
     * the likelihood that experiment x was conducted under that condition is
       maximal.
     */

    for (size_t x = 0; x < (size_t) b->objects; ++x)
    {

        size_t best_cx;
        best_cx = 0;

        /*
         * initialize the current maximal probability with the bottom value of
         * LogProbability
         */

        LogProbability maximal_prob;
        maximal_prob = LOG_PROB_LOWER_BOUND;

        for (size_t cx = 0; cx < (size_t) i->objects; ++cx)
        {
            /*
             * calculate (partial) likelihood if c(x) = cx
             */
            memset(l->match, 0, sizeof(size_t) * l->constants);
            memset(l->mismatch, 0, sizeof(size_t) * l->constants);

            for (size_t m = 0; m < attributes; ++m)
            {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
                if (gIm(x,b,m))
                {
                    if (gIm(cx,i,m))
                    {
#pragma GCC diagnostic pop
                        /*
                         * 1-eta(m,1)
                         */
                        l->match[eta->eta[1 * eta->constants + m]]++;
                        //printf("X");
                    }
                    else
                    {
                        /*
                         * eta(m,0)
                         */
                        l->mismatch[eta->eta[0 * eta->constants + m]]++;
                        //printf("O");
                    }
                }
                else
                {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
                    if (gIm(cx,i,m))
                    {
#pragma GCC diagnostic pop
                        /*
                         * eta(m,1)
                         */
                        l->mismatch[eta->eta[1 * eta->constants + m]]++;
                        //printf("_");
                    }
                    else
                    {
                        /*
                         * 1-eta(m,0)
                         */
                        l->match[eta->eta[0 * eta->constants + m]]++;
                        //printf(".");
                    }
                }
            }

            LogProbability p;
            p = logProbabilityFromProduct(log_c, l);

            //printf("%f\t", p);

            /*
             * cx is more likely than best_cx
             * so, update cx -> best_cx
             */

            if (maximal_prob <= p)
            {
                maximal_prob = p;
                best_cx = cx;
            }
        }

        /*
         * choose the most likely match
         */

        c->c[x] = best_cx;
        //printf("c(%4zu) = %4zu\n", x, c->c[x]);
    }

    deleteCommutativeProduct(&lp);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{easy_2measurement_8c_a521fc75fe217d457d76687a8cea85092_cgraph}
\end{center}
\end{figure}


